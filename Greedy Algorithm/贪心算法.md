# 贪心算法

## 一、贪心算法基础



**一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择得到全局最优的解决方案。**

​																																												——《算法导论》

贪心算法正是“活在当下，看清楚眼前”的办法。

贪心算法从**问题的初始解开始，一步一步地做出当前最好的选择，逐步逼近问题的目标，从而尽可能地得到最优解，即使达不到最优解，也可以得到最优解的近似解**。贪心算法只根据当前信息做出选择，而且一旦做出选择，则不管将来有什么结果，这个选择都不会改变。换言之，**贪心算法并不是从整体上做最优考虑，它所做出的选择只是某种意义上的局部最优。**



对于贪心算法，需要注意以下几个问题。

1. 一旦做出选择，就不可以回溯。
2. 有可能得不到最优解，而是得到最优解的近似解。
3. 选择什么样贪心策略直接决定算法的好坏。



人们经过实践发现，利用贪心算法求解的问题往往具有两个重要的性质：

- **贪心选择**：是指原问题的整体最优解可以通过一系列局部最优的选择得到：先做出当前最优的选择，将原问题变为一个相似却规模更小的子问题，而后的每一步都是当前最优的选择。这种选择依赖于已做出的选择，但不依赖于未做出的选择。
- **最优子结构**： 是指原问题的最优解包含子问题的最优解。贪心算法通过一系列的局部最优解（子问题的最优解）得到全局最优解（原问题的最优解），如果原问题的最优解和子问题的最优解没有关系，则求解子问题没有任何意义，无法采用贪心算法。



## 二、贪心算法的秘籍

只要问题满足贪心选择和最优子结构两个性质，就可以用使用贪心算法，那么具体如何使用呢？

1. 贪心策略：首先**要确定贪心策略，选择当前看上去最好的那个方案。**

   如挑选苹果为例，如果求解目标是越大越好，那么每次就从苹果堆中拿一个最大的苹果，作为局部最优解，贪心策略就是选择当前最大的苹果；

   如果求解目标是越红越好，那么每次就从苹果堆中拿一个最红的苹果，贪心策略就是选择当前最红的苹果。因此，根据求解目标的不同，贪心策略也会不同。

2. 求解过程：根据贪心策略，一步一步地得到局部最优解。

    如，首先选择一个最大的苹果，记为a1；然后从剩下的苹果中选择一个最大的苹果，记为a2；以此类推，对所有的局部最优解进行合并，即可得到原问题的最优解{a1,a2,...}。

   

举例说明：

海盗们截获一艘装满各种各样古董的货船，每一件古董都价值连城，但一旦打碎就会失去其原有的价值。海盗船虽然足够大，但载重量为30，

古董重量清单为:4,10,7,11,3,5,14,2

在不打碎古董且不超出载重量的情况下，怎样才能装入最多的古董，并显示相应古董的重量。

第一种方法

```C++ 
#include <iostream>
using namespace std;
const int N = 100;
const int W = 30;

double w[N] = {4,10,7,11,3,5,14,2};

int  solve2(int n)
{
    double tmp = 0.0;  //tmp为已装入海盗船的古董重量
    int ans = n;       //ans为已装入海盗船的古董数量，初始化为n;

    for(int i = 0; i < n; i++)
    {
        tmp += w[i];
        if(tmp >= W )  //只有最后依次才满足条件
        {
            if(tmp == W)
            {
                ans = i  + 1;
            }
            else
            {
                ans = i;
            }
            break;
        }
    }

    return ans;

}

void  Sort(double a[] )
{
    double  temp;
    int i, j, n;

    n = 0;
    while(a[n] != 0)  //计算数组的有效长度
    {
        n++;
    }

   for(i = 0; i < n - 1; i++)
   {
    for(j = 0; j < n - i - 1;j++)
    {
        if(a[j] > a[j+1])
        {
            temp = a[j];
            a[j] = a[j+1];
            a[j+1] = temp;
        }
    }
   }

   cout << endl;
   for(i = 0; i < n; i++)
    cout << a[i] << " ";

   cout << endl;

}


int main(void)
{ 
   int n;
   Sort(w);
   n = solve2(6);
   cout << n <<"件古董。" << endl;
   for(int i = 0; i < n; i++)
        cout << w[i] << " ";
    cout << endl;
   return 0;
    
}
```

第二种方法：使用STL

```C++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 100;
const int W = 30;

vector<double> w {4,10,7,11,3,5,14,2};
int  solve2(int n)
{
    double tmp = 0.0;  //tmp为已装入海盗船的古董重量
    int ans = n;       //ans为已装入海盗船的古董数量，初始化为n;

    for(int i = 0; i < n; i++)
    {
        tmp += w[i];
        if(tmp >= W )  //只有最后依次才满足条件
        {
            if(tmp == W)
            {
                ans = i  + 1;
            }
            else
            {
                ans = i;
            }
            break;
        }
    }

    return ans;

}

int main(void)
{
    vector<double>::iterator it;
    sort(w.begin(), w.end());

    for(it = w.begin(); it < w.end(); it++)
        cout << *it  << " ";
    cout << endl;
    int len = w.size();
    int count = solve2(len);
    cout << count <<"件古董！" << endl;
    for(it = w.begin(); it < w.begin()+count; it++)
        cout << *it  << " ";
    cout << endl;

    return 0;

}
```

